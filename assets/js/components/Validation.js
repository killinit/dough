/**
 * Client side validation. Mirrors HTML5 validation API as much as possible.
 *
 * Supported types are:
 * - required
 * - minlength
 * - pattern
 * - min/max number range checking
 *
 * @param  {Object} $         jQuery
 * @return {Class}           Validation
 */
define(['jquery', 'DoughBaseComponent'], function($, DoughBaseComponent) {
  'use strict';

  var defaultConfig = {
    invalidClass: 'is-invalid',
    validClass: 'is-valid',
    rowInvalidClass: 'is-errored'
  },

  uiEvents = {
    'blur input, select, textarea': '_handleBlurEvent',
    'keyup input, textarea': '_handleChangeEvent',
    'change select': '_handleChangeEvent',
    'submit': '_handleSubmit'
  },

  /**
   * Call base constructor
   * @constructor
   */
  Validation = function($el, config) {
    this.uiEvents = uiEvents;
    Validation.baseConstructor.apply(this, arguments);
    this.config = $.extend(defaultConfig, this.config);
    this.init();
  };

  DoughBaseComponent.extend(Validation);

  Validation.prototype.init = function() {
    this.ATTRIBUTE_VALIDATORS = {
      'required': '_validateRequired',
      'pattern': '_validatePattern',
      'min': '_validateMin',
      'max': '_validateMax',
      'minlength': '_validateMinLength'
    };

    this.errors = {};
    return this;
  };

  /**
   * Register an error, to be used with both inline and validation summary
   * @param {jQuery} $field        jQuery object of the field
   * @param {Object} fieldValidity The validity object generated by _getFieldValidity()
   * @return {Validation}        Class instance
   */
  Validation.prototype.addError = function($field, fieldValidity) {
    this.errors[$field.attr('id')] = fieldValidity;
    return this;
  };

  /**
   * Remove an error
   * @param  {jQuery} $field jQuery object of the field
   * @return {Validation}        Class instance
   */
  Validation.prototype.removeError = function($field) {
    delete this.errors[$field.attr('id')];
    return this;
  };

  /**
   * Check a field's validity and update the errors hash
   * @param  {jQuery} $field The field to validate
   * @return {Validation}        Class instance
   */
  Validation.prototype.checkFieldValidity = function($field) {
    var fieldValidity = this._getFieldValidity($field);

    if (fieldValidity.hasError) {
      this.addError($field, fieldValidity);
    }
    else {
      this.removeError($field);
    }

    console.log(this.errors);

    return this;
  };

  /**
   * Check a field's validity
   * @param  {jQuery} $field The field to validate
   * @return {Object}        A hash containing status and the appropriate error message
   */
  Validation.prototype._getFieldValidity = function($field) {
    var validity = {
      isEmpty: false,
      isInvalid: false,
      hasError: false,
      message: '',
      $field: $field
    };

    $.each(this.ATTRIBUTE_VALIDATORS, $.proxy(function(attributeSelector, handler) {
      var attr = $field.attr(attributeSelector);
      if (attr) {
        validity = this[handler]($field, $field.val(), attr, validity);
      }
    }, this));

    validity.hasError = validity.isEmpty || validity.isInvalid;

    if (validity.isEmpty) {
      validity.message = $field.attr('data-dough-validation-empty');
    }

    if (validity.isInvalid) {
      validity.message = $field.attr('data-dough-validation-invalid') || $field.attr('data-dough-validation-empty');
    }

    return validity;
  };


  Validation.prototype._validateRequired = function($field, value, required, validity) {
    if (value == '') {
      validity.isEmpty = true;
    }

    return validity;
  };

  Validation.prototype._validatePattern = function($field, value, pattern, validity) {
    if (!value.match(pattern)) {
      validity.isInvalid = true;
    }

    return validity;
  };

  Validation.prototype._validateMin = function($field, value, min, validity) {
    if (Number(value) < min) {
      validity.isInvalid = true;
    }

    return validity;
  };

  Validation.prototype._validateMax = function($field, value, max, validity) {
    if (Number(value) > min) {
      validity.isInvalid = true;
    }

    return validity;
  };

  Validation.prototype._validateMinLength = function($field, value, minlength, validity) {
    if (value.length < minlength) {
      validity.isInvalid = true;
    }

    return validity;
  };



  /**
   * Inline errors are shown on input blur
   * @param  {Event} e BlurEvent
   * @return {void}
   */
  Validation.prototype._handleBlurEvent = function(e) {
    this.checkFieldValidity($(e.target));
  };

  /**
   * Error messages get corrected as the user types. Only do this if we can see an error exists.
   * @param  {Object} e ChangeEvent
   * @return {void}
   */
  Validation.prototype._handleChangeEvent = function(e) {
    var $field = $(e.target);

    if (typeof this.errors[$field.attr('id')] === 'object') {
      this.checkFieldValidity($field);
    }
  };

  /**
   * The validation summary is updated on form submit
   * @return {void}
   */
  Validation.prototype._handleSubmit = function() {

  };


  return Validation;

});
